export const __webpack_id__=610;export const __webpack_ids__=[610];export const __webpack_modules__={3610:(e,t,o)=>{o.d(t,{fromHttp:()=>h});var r=o(244),n=o(3621),s=o(8112),a=o(1943),i=o.n(a),c=o(5479),l=o(1540),d=o(6728);const h=(e={})=>{let t;e.logger?.debug("@aws-sdk/credential-provider-http - fromHttp");const o=e.awsContainerCredentialsRelativeUri??process.env.AWS_CONTAINER_CREDENTIALS_RELATIVE_URI,a=e.awsContainerCredentialsFullUri??process.env.AWS_CONTAINER_CREDENTIALS_FULL_URI,h=e.awsContainerAuthorizationToken??process.env.AWS_CONTAINER_AUTHORIZATION_TOKEN,p=e.awsContainerAuthorizationTokenFile??process.env.AWS_CONTAINER_AUTHORIZATION_TOKEN_FILE,g="NoOpLogger"!==e.logger?.constructor?.name&&e.logger?e.logger.warn:console.warn;if(o&&a&&(g("@aws-sdk/credential-provider-http: you have set both awsContainerCredentialsRelativeUri and awsContainerCredentialsFullUri."),g("awsContainerCredentialsFullUri will take precedence.")),h&&p&&(g("@aws-sdk/credential-provider-http: you have set both awsContainerAuthorizationToken and awsContainerAuthorizationTokenFile."),g("awsContainerAuthorizationToken will take precedence.")),a)t=a;else{if(!o)throw new s.C1("No HTTP credential provider host provided.\nSet AWS_CONTAINER_CREDENTIALS_FULL_URI or AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.",{logger:e.logger});t=`http://169.254.170.2${o}`}const u=new URL(t);((e,t)=>{if("https:"!==e.protocol&&"169.254.170.2"!==e.hostname&&"169.254.170.23"!==e.hostname&&"[fd00:ec2::23]"!==e.hostname){if(e.hostname.includes("[")){if("[::1]"===e.hostname||"[0000:0000:0000:0000:0000:0000:0000:0001]"===e.hostname)return}else{if("localhost"===e.hostname)return;const t=e.hostname.split("."),o=e=>{const t=parseInt(e,10);return 0<=t&&t<=255};if("127"===t[0]&&o(t[1])&&o(t[2])&&o(t[3])&&4===t.length)return}throw new s.C1("URL not accepted. It must either be HTTPS or match one of the following:\n  - loopback CIDR 127.0.0.0/8 or [::1/128]\n  - ECS container host 169.254.170.2\n  - EKS container host 169.254.170.23 or [fd00:ec2::23]",{logger:t})}})(u,e.logger);const w=new n.$c({requestTimeout:e.timeout??1e3,connectionTimeout:e.timeout??1e3});return C=async()=>{const t=function(e){return new c.Kd({protocol:e.protocol,hostname:e.hostname,port:Number(e.port),path:e.pathname,query:Array.from(e.searchParams.entries()).reduce(((e,[t,o])=>(e[t]=o,e)),{}),fragment:e.hash})}(u);h?t.headers.Authorization=h:p&&(t.headers.Authorization=(await i().readFile(p)).toString());try{return async function(e,t){const o=(0,d.c9)(e.body),r=await o.transformToString();if(200===e.statusCode){const e=JSON.parse(r);if("string"!=typeof e.AccessKeyId||"string"!=typeof e.SecretAccessKey||"string"!=typeof e.Token||"string"!=typeof e.Expiration)throw new s.C1("HTTP credential provider response not of the required format, an object matching: { AccessKeyId: string, SecretAccessKey: string, Token: string, Expiration: string(rfc3339) }",{logger:t});return{accessKeyId:e.AccessKeyId,secretAccessKey:e.SecretAccessKey,sessionToken:e.Token,expiration:(0,l.EI)(e.Expiration)}}if(e.statusCode>=400&&e.statusCode<500){let o={};try{o=JSON.parse(r)}catch(e){}throw Object.assign(new s.C1(`Server responded with status: ${e.statusCode}`,{logger:t}),{Code:o.Code,Message:o.Message})}throw new s.C1(`Server responded with status: ${e.statusCode}`,{logger:t})}((await w.handle(t)).response).then((e=>(0,r.g)(e,"CREDENTIALS_HTTP","z")))}catch(t){throw new s.C1(String(t),{logger:e.logger})}},T=e.maxRetries??3,_=e.timeout??1e3,async()=>{for(let e=0;e<T;++e)try{return await C()}catch(e){await new Promise((e=>setTimeout(e,_)))}return await C()};var C,T,_}}};